<!--
    ------[Introdu√ß√£o e contexto hist√≥rico]
    ------[Explica√ß√£o t√©cnica detalhada]
    - Visualiza√ß√£o interativa ou anima√ß√£o
    - Exemplos de c√≥digo comentados
    ------[An√°lise de complexidade]
    - Aplica√ß√µes pr√°ticas
    ------[Compara√ß√£o com estruturas similares]
    ------[Refer√™ncias bibliogr√°ficas]


-->
<!--
    - Visualiza√ß√£o do array de bits e fun√ß√µes hash
    - Demonstra√ß√£o interativa de inser√ß√£o e consulta
    ------[Gr√°fico: taxa de falso positivo vs. tamanho do filtro]
    - Calculadora de par√¢metros √≥timos (tamanho e n√∫mero de hashes)
    ------[Implementa√ß√£o em C com fun√ß√µes hash]

-->

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/textStyles.css">
    <title>Bloom Filter</title>
</head>
<body>
    <header>
        <h1>Bloom Filter</h1>
    </header>
    <main>
        <section id="intro">
            <h2>Introdu√ß√£o</h2>
            <p>Um Bloom Filter √© uma estrutura de dados probabil√≠stica que analisa se uma informa√ß√£o est√° num conjunto de dados sem precisar acessar a mem√≥ria em disco. Eventualmente, a estrutura pode apontar um falso positivo (indicando que um elemento est√° em um conjunto quando, na verdade, n√£o est√°). Entretanto, jamais gera um falso negativo. Quanto mais elementos s√£o adicionados a uma Bloom filter, maiores s√£o as chances de um falso positivo.</p>
            <p>Ou seja, √© poss√≠vel enviar para o ‚Äúlado cliente‚Äù de um software informa√ß√£o suficiente para reduzir dramaticamente requests in√≥cuos e, por consequ√™ncia, trafego na rede, acessos a ‚Äúdisco‚Äù e aloca√ß√µes desnecess√°rias em mem√≥ria. Afinal, antes de fazer uma requisi√ß√£o ao servidor para verificar a ‚Äúpresen√ßa‚Äù de um dado em um conjunto, bastaria o ‚Äúlado cliente‚Äù consultar, antes, ao filtro, podendo prover feedback muito mais r√°pido sem onerar o backend.</p>
            <p>O segredo para a efici√™ncia dessa estrutura de dados √© a utiliza√ß√£o de hashes de qualidade que s√£o utilizados para ligar ou desligar bits em um mapa. Sempre que um dado √© ‚Äúinclu√≠do‚Äù no filtro, os bits correspondentes do hash s√£o ligados.</p>
        </section>
        <section id="contextoHistorico">
            <h2>Contexto hist√≥rico</h2>
            <p>Esta estrutura de dados foi concebida por Burton Howard Bloom em 1970 que demanda pouco espa√ßo. Ela √© utilizada para testar se um elemento est√° presente em um conjunto sem necessitar consultar a lista completa de elementos presente nesse conjunto.</p>
            <p>O trabalho de Pagh, em 2005 prop√µe uma estrutura de dados de Bloom Filter teoricamente quase √≥tima em espa√ßo, usando hashing perfeito para lidar com conjuntos de chaves est√°ticos. Essa estrutura, por√©m, n√£o era pr√°tica por duas raz√µes.</p>
            <p>Primeiro, na √©poca, s√≥ existiam algoritmos te√≥ricos de hashing perfeito quase √≥timo em espa√ßo. Esse problema foi resolvido com novos desenvolvimentos em fun√ß√µes de hash perfeitas, que requerem aproximadamente 2,6 bits por chave armazenada e podem ser avaliadas em tempo O(1).</p>
            <p>Segundo, n√£o era poss√≠vel representar uma fun√ß√£o hash totalmente aleat√≥ria sem desperdi√ßar O(n log n) bits. Esse problema foi resolvido pela t√©cnica split-and-share, proposta em 2007 por Dietzfelbinger e Weidling, tornando poss√≠vel usar O(n) bits para representar uma fun√ß√£o hash totalmente aleat√≥ria.</p>
        </section>
        <section id="explicacao">
            <h2>Explica√ß√£o T√©cnica</h2>
            <p>Um filtro de Bloom funciona armazenando o conjunto S como um vetor de bits BS, em que os bits s√£o ativados por um conjunto de fun√ß√µes hash verdadeiramente aleat√≥rias. Ele come√ßa como um vetor de todos os bits 0. Cada elemento xi do conjunto S √© hasheado k vezes, e cada hash gera uma posi√ß√£o de bit que √© configurada como 1. Para verificar se um elemento y pertence ao conjunto, faz-se o hash dele k vezes e verifica-se se os bits correspondentes est√£o definidos como 1.</p>
            <article id="falsosPositivos">
                <p>Dada a possibilidade de ocorr√™ncia de resultados falsos positivos, o Bloom filter √© uma estrutura de dados especialmente adequada para cen√°rios em que os m√©todos convencionais (n√£o probabil√≠sticos, livres de erros) para responder a testes de membresia demandem uma quantidade impratic√°vel de espa√ßo. Ademais, Bloom sugere o uso dessa estrutura para aplica√ß√µes em que a grande maioria dos elementos testados n√£o fazem parte do conjunto representado pela estrutura. Define-se tempo de rejei√ß√£o como o tempo m√©dio dispendido por uma estrutura de dados para decidir que um dado elemento n√£o pertence ao conjunto representado. De fato, o Bloom filter permite diminuir o consumo de espa√ßo sem acrescer o tempo de rejei√ß√£o, o que ocorre com o custo de resultados falsos positivos e impossibilidade de remo√ß√£o de elementos da estrutura.</p>
                <div id="grafico">
                    <img src="../images/Captura de tela 2025-11-04 094435.png" alt="Gr√°fico falsos positivos vs tamanho do filtro">
                </div>
            </article>
        </section>
        <section id="assintotica">
            <h2>Complexidade de tempo</h2>
            <p>Em qualquer aplica√ß√£o em que falsos positivos n√£o causem problemas significativos, apenas uma aproxima√ß√£o de S pode ser armazenada em vez de guardar explicitamente o conjunto, fornecendo assim uma representa√ß√£o mais compacta que pode caber na mem√≥ria. Se cada elemento que n√£o pertence a S for um falso positivo com probabilidade de, no m√°ximo, &#491;, ent√£o o n√∫mero de bits necess√°rios para armazenar a aproxima√ß√£o √© aproximadamente n log‚ÇÇ (1/&#491;), enquanto, para evitar falsos positivos, seria necess√°rio armazenar S em pelo menos n log‚ÇÇ n bits.</p>
            <p>Considere o conjunto S' &supseteq; S, que inclui os elementos armazenados, inclusive os falsos positivos. O conjunto S' √© escolhido de forma que qualquer elemento que n√£o perten√ßa a S tenha probabilidade de, no m√°ximo, &#491; de pertencer a S'. Um filtro de Bloom (Bloom, 1970) √© uma estrutura de dados extremamente compacta e elegante para representar um conjunto S' adequado.</p>
        </section>
        <section id="estruturasSimilares">
            <h2>Compara√ß√£o com estruturas similares</h2>
            <article id="cuckooFilter">
                <h3>Cuckoo Filter</h3>
                <p>O Cuckoo filter √© proposto como uma alternativa ao Bloom filter tradicional para os cen√°rios em que haja remo√ß√£o de elementos da estrutura, mas sem que haja necessidade de usar um espa√ßo adicional. Vantagens do cuckoo filter sobre o Bloom filter tradicional e outros filtros que permitem remo√ß√µes de elementos:</p>
                <ul>
                    <li>Permite adicionar e remover itens dinamicamente;</li>
                    <li>Fornece melhor desempenho de consultas do que o Bloom filter tradicional, mesmo quando est√° quase cheio (com 95% do espa√ßo utilizado, por exemplo);</li>
                    <li>√â mais f√°cil de implementar do que alternativas como o quotient filter;</li>
                    <li>Usa menos espa√ßo que os Bloom filters em muitas aplica√ß√µes pr√°ticas se a raz√£o de falsos positivos ùúñ alvo √© menor que 3%.</li>
                </ul>
            </article>
            <article id="quaotientFilter">
                <h3>Quotient Filter</h3>
                <ul>
                    <li>Melhor desempenho poque requer apenas uma consulta de cache em m√©dia;</li>
                    <li>tamb√©m suporta a exclus√£o, mas n√£o elimina outros dados ao mesmo tempo;</li>
                    <li>N√£o altera a taxa de falso positivo.</li>
                </ul>
            </article>
            <article id="countingBloomFilter">
                <h3>Counting Bloom Filter</h3>
                <ul>
                    <li>Usa contadores ao inv√©s de bits simples;</li>
                    <li>utiliza mais mem√≥ria;</li>
                    <li>Mas durante uma remo√ß√£o, ele pode invalidar um bit que estava sendo utilizado por outro dado.</li>
                </ul>
            </article>
        </section>
        <section id="simulacao">

        </section>
        <section id="referenciasBibliograficas">
            <h3>Refer√™ncias Bibliogr√°ficas</h3>
            <ul>
                <li><a href=" https://homepages.dcc.ufmg.br/~nivio/papers/iadis-www-internet11.pdf" target="_blank">N√çVIO, M.; et al. Minimal perfect hashing and Bloom filters: a practical implementation for static sets. IADIS International Journal on WWW/Internet, v. 11, n. 2, p. xx-yy, 2013.</a></li>
                <li><a href="https://www.eecs.harvard.edu/~michaelm/NEWWORK/postscripts/BloomFilterSurvey.pdf" target="_blank">BRODER, A.; MITZENMACHER, M. Network applications of Bloom filters: a survey. Harvard University / IBM Research, 2004</a></li>
                <li><a href="https://linux.ime.usp.br/~mbsilva/mac0499/monografia.pdf" target="_blank">SILVA, M. B. Estudo do efeito de varia√ß√µes de Bloom filters no desempenho de algoritmos de hifeniza√ß√£o de palavras. 2022. 43 f. Monografia (Bacharelado em Ci√™ncia da Computa√ß√£o) ‚Äî Instituto de Matem√°tica e Estat√≠stica, Universidade de S√£o Paulo, S√£o Paulo, 2022.</a></li>
                <li><a href="https://eximia.co/como-bloom-filter-pode-ser-utilizada-para-melhorar-a-performance/" target="_blank">J√öNIOR, Elemar. Como ‚ÄúBloom Filter‚Äù pode ser utilizada para melhorar a performance. EximiaCo Insights, 30 jun. 2020</a></li>
            </ul>
        </section>
    </main>
    <footer>

    </footer>
</body>
</html>