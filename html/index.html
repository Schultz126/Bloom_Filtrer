<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pattaya&display=swap" rel="stylesheet">

    <title>Bloom Filter</title>
</head>
<body>
    <header>
        <h1>Bloom Filter</h1>
    </header>

    <div class="scene">
        <div class="flower" id="flower">
            <div class="bud"></div>
            <div class="center"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
            <div class="petal"></div>
        </div>
    </div>

    <main>
        <section id="intro">
            <h2>Introdu√ß√£o</h2>
            <p>Um Bloom Filter √© uma estrutura de dados probabil√≠stica que analisa se uma informa√ß√£o est√° num conjunto de dados sem precisar acessar a mem√≥ria em disco. Eventualmente, a estrutura pode apontar um falso positivo (indicando que um elemento est√° em um conjunto quando, na verdade, n√£o est√°). Entretanto, jamais gera um falso negativo. Quanto mais elementos s√£o adicionados a uma Bloom filter, maiores s√£o as chances de um falso positivo.</p>
            <p>Ou seja, √© poss√≠vel enviar para o ‚Äúlado cliente‚Äù de um software informa√ß√£o suficiente para reduzir dramaticamente requests in√≥cuos e, por consequ√™ncia, trafego na rede, acessos a ‚Äúdisco‚Äù e aloca√ß√µes desnecess√°rias em mem√≥ria. Afinal, antes de fazer uma requisi√ß√£o ao servidor para verificar a ‚Äúpresen√ßa‚Äù de um dado em um conjunto, bastaria o ‚Äúlado cliente‚Äù consultar, antes, ao filtro, podendo prover feedback muito mais r√°pido sem onerar o backend.</p>
            <p>O segredo para a efici√™ncia dessa estrutura de dados √© a utiliza√ß√£o de hashes de qualidade que s√£o utilizados para ligar ou desligar bits em um mapa. Sempre que um dado √© ‚Äúinclu√≠do‚Äù no filtro, os bits correspondentes do hash s√£o ligados.</p>
            <p>Ou seja, √© poss√≠vel enviar para o ‚Äúlado cliente‚Äù de um software informa√ß√£o suficiente para reduzir dramaticamente requests in√≥cuos e, por consequ√™ncia, trafego na rede, acessos a ‚Äúdisco‚Äù e aloca√ß√µes desnecess√°rias em mem√≥ria. Afinal, antes de fazer uma requisi√ß√£o ao servidor para verificar a ‚Äúpresen√ßa‚Äù de um dado em um conjunto, bastaria o ‚Äúlado cliente‚Äù consultar, antes, ao filtro, podendo prover feedback muito mais r√°pido sem sobrecarregar o backend.</p>
            <p>O segredo para a efici√™ncia dessa estrutura de dados √© a utiliza√ß√£o de hashes de qualidade que s√£o utilizados para ligar ou desligar bits em um mapa. Sempre que um dado √© ‚Äúinclu√≠do‚Äù no filtro, os bits correspondentes do hash s√£o ligados. Em sistemas distribu√≠dos ou que manipulam grandes volumes de dados, a verifica√ß√£o direta em estruturas completas pode ser invi√°vel devido ao custo de mem√≥ria e tempo. Assim, o Bloom Filter se torna uma alternativa leve para consultas r√°pidas.</p>
        </section>

        <section id="contextoHistorico">
            <h2>Contexto hist√≥rico</h2>

        </section>

        <section id="explicacaoTecnica">
            <h2>Explica√ß√£o T√©cnica</h2>
            <p>Um filtro de Bloom funciona armazenando o conjunto S como um vetor de bits BS, em que os bits s√£o ativados por um conjunto de fun√ß√µes hash verdadeiramente aleat√≥rias. Ele come√ßa como um vetor de todos os bits 0. Cada elemento xi do conjunto S √© hasheado k vezes, e cada hash gera uma posi√ß√£o de bit que √© configurada como 1. Para verificar se um elemento y pertence ao conjunto, faz-se o hash dele k vezes e verifica-se se os bits correspondentes est√£o definidos como 1.</p>
            <article id="falsosPositivos">
                <p>Dada a possibilidade de ocorr√™ncia de resultados falsos positivos, o Bloom filter √© uma estrutura de dados especialmente adequada para cen√°rios em que os m√©todos convencionais (n√£o probabil√≠sticos, livres de erros) para responder a testes de membresia demandem uma quantidade impratic√°vel de espa√ßo. Ademais, Bloom sugere o uso dessa estrutura para aplica√ß√µes em que a grande maioria dos elementos testados n√£o fazem parte do conjunto representado pela estrutura. Define-se tempo de rejei√ß√£o como o tempo m√©dio dispendido por uma estrutura de dados para decidir que um dado elemento n√£o pertence ao conjunto representado. De fato, o Bloom filter permite diminuir o consumo de espa√ßo sem acrescer o tempo de rejei√ß√£o, o que ocorre com o custo de resultados falsos positivos e impossibilidade de remo√ß√£o de elementos da estrutura.</p>
              <p>Dada a possibilidade de ocorr√™ncia de resultados falsos positivos, o Bloom filter √© uma estrutura de dados especialmente adequada para cen√°rios em que os m√©todos convencionais (n√£o probabil√≠sticos, livres de erros) para responder a testes de membresia demandem uma quantidade impratic√°vel de espa√ßo. Ademais, Bloom sugere o uso dessa estrutura para aplica√ß√µes em que a grande maioria dos elementos testados n√£o fazem parte do conjunto representado pela estrutura. De fato, o Bloom filter permite diminuir o consumo de espa√ßo sem acrescer o tempo de rejei√ß√£o(tempo m√©dio dispendido por uma estrutura de dados para decidir que um dado elemento n√£o pertence ao conjunto representado), o que ocorre com o custo de resultados falsos positivos e impossibilidade de remo√ß√£o de elementos da estrutura.</p>
                <div id="grafico">
                    <img src="../images/grafico.FalsoPositivoVSTamanhoDoFiltro.png" alt="Gr√°fico falsos positivos vs tamanho do filtro">
                </div>
            </article>
        </section>
      
    <section id="assintotica">
            <h2>Complexidade de tempo</h2>
            <p>Em qualquer aplica√ß√£o em que falsos positivos n√£o causem problemas significativos, apenas uma aproxima√ß√£o de S pode ser armazenada em vez de guardar explicitamente o conjunto, fornecendo assim uma representa√ß√£o mais compacta que pode caber na mem√≥ria. Se cada elemento que n√£o pertence a S for um falso positivo com probabilidade de, no m√°ximo, &#491;, ent√£o o n√∫mero de bits necess√°rios para armazenar a aproxima√ß√£o √© aproximadamente n log‚ÇÇ (1/&#491;), enquanto, para evitar falsos positivos, seria necess√°rio armazenar S em pelo menos n log‚ÇÇ n bits.</p>
            <p>Considere o conjunto S' &supseteq; S, que inclui os elementos armazenados, inclusive os falsos positivos. O conjunto S' √© escolhido de forma que qualquer elemento que n√£o perten√ßa a S tenha probabilidade de, no m√°ximo, &#491; de pertencer a S'. Um filtro de Bloom (Bloom, 1970) √© uma estrutura de dados extremamente compacta e elegante para representar um conjunto S' adequado.</p>
        </section>
        <section id="estruturasSimilares">
            <h2>Compara√ß√£o com estruturas similares</h2>
            <article id="cuckooFilter">
                <h3>Cuckoo Filter</h3>
                <p>O Cuckoo filter √© proposto como uma alternativa ao Bloom filter tradicional para os cen√°rios em que haja remo√ß√£o de elementos da estrutura, mas sem que haja necessidade de usar um espa√ßo adicional. Vantagens do cuckoo filter sobre o Bloom filter tradicional e outros filtros que permitem remo√ß√µes de elementos:</p>
                <ul>
                    <li>Permite adicionar e remover itens dinamicamente;</li>
                    <li>Fornece melhor desempenho de consultas do que o Bloom filter tradicional, mesmo quando est√° quase cheio (com 95% do espa√ßo utilizado, por exemplo);</li>
                    <li>√â mais f√°cil de implementar do que alternativas como o quotient filter;</li>
                    <li>Usa menos espa√ßo que os Bloom filters em muitas aplica√ß√µes pr√°ticas se a raz√£o de falsos positivos ùúñ alvo √© menor que 3%.</li>
                </ul>
            </article>
            <article id="quaotientFilter">
                <h3>Quotient Filter</h3>
              <ul>
                    <li>Melhor desempenho poque requer apenas uma consulta de cache em m√©dia;</li>
                    <li>tamb√©m suporta a exclus√£o, mas n√£o elimina outros dados ao mesmo tempo;</li>
                    <li>N√£o altera a taxa de falso positivo.</li>
                </ul>
            </article>
            <article id="countingBloomFilter">
                <h3>Counting Bloom Filter</h3>
                <ul>
                    <li>Usa contadores ao inv√©s de bits simples;</li>
                    <li>utiliza mais mem√≥ria;</li>
                    <li>Mas durante uma remo√ß√£o, ele pode invalidar um bit que estava sendo utilizado por outro dado.</li>
                </ul>
            </article>
        </section>
        <section>
            <h2>Aplica√ß√µes</h2>
            <article id="redesP2P"> 
                <h3>Redes P2P/ Overlay</h3>
                <ul>
                    <li>Redes P2P de tamanho moderado;</li>
                  <li>Reconcilia√ß√£o aproximada de conjuntos para entrega de conte√∫do;</li>
                    <li>Interse√ß√£o de conjuntos para buscas por palavra-chave.</li>
                </ul>
            </article>
            <article id="recursos">
                <h3>Roteamento</h3>
                <ul>
                    <li>Um protocolo b√°sico de roteamento</li>
                    <li>Roteamento de recursos em redes P2P</li>
                    <li>Roteamento geogr√°fico</li>
                </ul>
            </article>
            <article id="pacotes">
                <h3>Roteamento de Pacotes</h3>
                <ul>
                    <li>Detec√ß√£o de loops no Icarus</li>
                    <li>Gerenciamento de filas: Stochastic Fair Blue</li>
                    <li>Multicast</li>
                </ul>
            </article>
        </section>
      </ul>
            </article>
        </section>
        <section id="simulacao">

            </article>
        </section>
        <section id="referenciasBibliograficas">
            <h3>Refer√™ncias Bibliogr√°ficas</h3>
            <ul>
                <li><a href=" https://homepages.dcc.ufmg.br/~nivio/papers/iadis-www-internet11.pdf" target="_blank">N√çVIO, M.; et al. Minimal perfect hashing and Bloom filters: a practical implementation for static sets. IADIS International Journal on WWW/Internet, v. 11, n. 2, p. xx-yy, 2013.</a></li>
                <li><a href="https://www.eecs.harvard.edu/~michaelm/NEWWORK/postscripts/BloomFilterSurvey.pdf" target="_blank">BRODER, A.; MITZENMACHER, M. Network applications of Bloom filters: a survey. Harvard University / IBM Research, 2004</a></li>
                <li><a href="https://linux.ime.usp.br/~mbsilva/mac0499/monografia.pdf" target="_blank">SILVA, M. B. Estudo do efeito de varia√ß√µes de Bloom filters no desempenho de algoritmos de hifeniza√ß√£o de palavras. 2022. 43 f. Monografia (Bacharelado em Ci√™ncia da Computa√ß√£o) ‚Äî Instituto de Matem√°tica e Estat√≠stica, Universidade de S√£o Paulo, S√£o Paulo, 2022.</a></li>
                <li><a href="https://eximia.co/como-bloom-filter-pode-ser-utilizada-para-melhorar-a-performance/" target="_blank">J√öNIOR, Elemar. Como ‚ÄúBloom Filter‚Äù pode ser utilizada para melhorar a performance. EximiaCo Insights, 30 jun. 2020</a></li>
            </ul>
        </section>

    </main>

    <footer>
        <p>¬© 2025 - Estrutura de Dados</p>
    </footer>

    <script>
      window.addEventListener('load', () => {
        setTimeout(() => {
          document.getElementById('flower').classList.add('open');
        }, 1000);
      });
    </script>
</body>
</html>
